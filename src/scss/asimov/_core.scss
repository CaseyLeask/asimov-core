
$__a__cache-enabled: true !default;
$__a__map-cache: () !default;

// ==========================================================================
// Settings API
// ==========================================================================

// Returns $key's value from the core $settings map
// -----------------------------------------------------------------------------
// @param $key [String] : flattened key to lookup
// -----------------------------------------------------------------------------
// @return [Literal]
@function get($key) {
    @return lookup(get-component-map("settings", $settings, true), $key);
}


// Sets $key's to $value in the core $settings map if it currently has now value
// If $key was a string it's new value is returned
// If $key was a map the core $settings map is returned
// -----------------------------------------------------------------------------
// @param $key [String|Map] : key to lookup or map to merge with $settings
// @param $value [Literal] : value to set $key to it was a string
// -----------------------------------------------------------------------------
// @return [Literal]
@function set-default($key, $value:null) {
    // Clear the settings caches!
    $foo: cache-clean("settings");
    $foo: cache-clean("settings--flat");
    $foo: cache-disable();

    @if type-of($key) == map {
        // Reverse the merge order so we don't over write anything
        $settings: _set($settings, $value, $key) !global;
        @return $settings;
    } @else if not get($key) {
        $settings: _set($key, $value, $settings) !global;
        // This rebuilds the settings cache if it was busted
        @return get($key);
    }

    // $key exists in $settings, do nothing!
    @return $value;
}


// Sets $key's to $value in the core $settings map
// If $key was a string it's new value is returned
// If $key was a map the core $settings map is returned
// -----------------------------------------------------------------------------
// @param $key [String|Map] : key to lookup or map to merge with $settings
// @param $value [Literal] : value to set $key to it was a string
// -----------------------------------------------------------------------------
// @return [Literal]
@function set($key, $value:null) {
    // Clear the settings caches!
    $foo: cache-clean("settings") && cache-clean("settings--flat");

    $settings: _set($key, $value, $settings) !global;
    // This rebuilds the settings cache if it was busted
    @return get($key);
}


// Sets $key's to $value in the core $settings map
// Returning the value of $key after it's been updated. If $key was a map the
// root node is returned
// -----------------------------------------------------------------------------
// @param $key [String|Map] : key to lookup or map to merge with $settings
// @param $value [Literal] : value to set $key to it was a string
// @param $_root [Map] : for internal use only
// -----------------------------------------------------------------------------
// @return [Literal]
@function _set($key, $value:null, $_root:null) {
    // $_root won't exist in recursive calls if $key is a new branch
    @if $_root == null {
        $_root: ($key: ());
    }

    // If $key is a map just merge it and move on
    //
    // 1: this allows use to use () as the default $settings value
    @if type-of($key) == map or
        type-of($key) == list // 1
    {
        @return map-merge-recursive($_root, $key);
    }

    @if str-index($key, "/") > 0 {
        // Determin the $new key for the recursion
        $child-key: str-slice($key, str-index($key, "/") + 1);

        // Override the original $key and $value we can have one @return
        $key: str-slice($key, 1, str-index($key, "/") - 1);
        $value: _set($child-key, $value, map-get($_root, $key))
    }

    @return map-merge($_root, ($key: $value));
}


// ==========================================================================
// Internal caching API
// ==========================================================================

// Clears the internal cache. If $key is supplied only that key is cleared
// Returned the new state of the cache
// -----------------------------------------------------------------------------
// @param $key [String] : an optional key to clear
// -----------------------------------------------------------------------------
// @return [Map]
@function cache-clean($key:null) {
    @if $key {
        $__a__map-cache: map-merge($__a__map-cache, ($key: null)) !global;
    } @else {
        $__a__map-cache: () !global;
    }

    @return $__a__map-cache;
}


// Returns whether the internal cache is enabled or not
// -----------------------------------------------------------------------------
// @return [Bool] true if the cache is enabled, otherwise false
@function cache-status() {
    @return $__a__cache-enabled;
}


// Disables the internal cache
// -----------------------------------------------------------------------------
// @return [Bool] true if the cache is enabled, otherwise false
@function cache-disable() {
    $__a__cache-enabled: false !global;
    @return cache-status();
}


// Disables the internal cache
// -----------------------------------------------------------------------------
// @return [Bool] true if the cache is enabled, otherwise false
@function cache-enable() {
    $__a__cache-enabled: true !global;
    @return cache-status();
}


// ==========================================================================
// List functions
// ==========================================================================

// Return the first dimension of a multi dimensional $map with aliases resolved
// -----------------------------------------------------------------------------
// @param $map [Map] : map
// -----------------------------------------------------------------------------
// @return [Map]
@function get-map($map) {
    $ret: ();
    $base: null;
    @each $name, $value in $map {
        // ignore "base" as a value
        @if type-of($value) != map and $name != "base" {
            $ret: map-merge($ret, ($name: $value));
        } @else if $name == "base" {
            // preserver the "base" value for later
            $base: $value;
        }
    }

    // inject the "base" value for alias lookups only
    @return resolve-aliases($ret, ("base": $base));
}


// Turns multidimensional $map into a one-level map with aliases resolved.
// Map keys are composed by prefixing it's parent's key separated by a /
// -----------------------------------------------------------------------------
// @param $map [Map] : map
// @param $ret [Map] : the parent map to flatten $map into
// @param $prefix [String] : the prefix to append to $map's keys
// -----------------------------------------------------------------------------
// @return [Map]
@function flatten-map($map, $ret:(), $prefix:null) {
    @each $name, $value in $map {
        // TODO 3.3: this can be simplified with `if()`
        @if $prefix {
            $name: $prefix + if($name, "/#{$name}", "");
        }

        @if type-of($value) == map {
            // Append to the end of the root map because alias need to be after
            // the value they're aliasing to resolve correctly "#{$name}-base"
            $ls: append($value, null "#{$name}/base");
            $ret: flatten-map($ls, $ret, $name);
        } @else {
            $ret: map-merge($ret, ($name: $value));
        }
    }

    @return $ret;
}


// Takes a one dimensional $map and returns a new map with aliases resolved
// -----------------------------------------------------------------------------
// @param $map [Map] : map
// @param $extras [Map] : an external map to resolve aliases against
// -----------------------------------------------------------------------------
// @return [Map]
@function resolve-aliases($map, $extras:()) {
    $ret: ();
    @each $name, $value in $map {
        // Looks like an alias, try to resolve it, default to $value
        @if type-of($value) == string {
            $value: lookup($ret, $value, lookup($extras, $value, $value));
            $ret: map-merge($ret, ($name: $value));
        } @else {
            $ret: map-merge($ret, ($name: $value));
        }
    }

    @return $ret;
}


// Takes a one dimensional $map and returns a new map with aliases resolved
// -----------------------------------------------------------------------------
// @param $map [Map] : map
// @param $key [String] : key to lookup in map
// @param $default [Value] : the default value to return if key is not found
// @param $is-key [Bool] : if true $default is treated as a key in $map
// -----------------------------------------------------------------------------
// @return [Literal]
@function lookup($map, $key, $default:null, $is-key:false) {
    @if length($map) == 0 {
        @return $default;
    }

    @if map-has-key($map, $key) {
        @return map-get($map, $key);
    }

    @return if($is-key, lookup($map, $default), $default);
}


// Main proxy for accessing settings maps. Returned maps can either be just
// root level keys, or the entire map flattened with / used to flatten keys.
// Fetches are cached using $name and $flatten as seeds for the cache key.
// -----------------------------------------------------------------------------
// @param $name [String] : used a cache key
// @param $map [Map] : the map you want to retrieve
// @param $flatten [Bool] : whethen to flatten the map or just return root keys
// -----------------------------------------------------------------------------
// @return [Literal]
@function get-component-map($name, $map, $flatten:false) {
    $name: $name + if($flatten, "--flat", "");

    $ret: lookup($__a__map-cache, $name);
    @if $ret == null {
        $ret: if($flatten, resolve-aliases(flatten-map($map)), get-map($map));
    }

    @if $__a__cache-enabled {
        $__a__map-cache: map-merge($__a__map-cache, ($name: $ret));
    }

    @return $ret;
}


// Joins all elements of single dimensional $list with $glue
// -------------------------------------------------------------------------------
// @param $list [List] : list
// @param $glue [String] : value to use as a join string
// -------------------------------------------------------------------------------
// @return [String]
@function implode($list, $glue:",") {
    @if length($list) == 1 {
        @return $list;
    }

    $ret: unquote("");
    @for $i from 1 through length($list) {
        $ret: if($ret == "", $ret, $ret + $glue) + nth($list, $i);
    }

    @return $ret;
}


// Joins all elements of single dimensional $list with $glue
// -------------------------------------------------------------------------------
// @param $list [List] : list
// @param $glue [String] : value to use as a join string
// -------------------------------------------------------------------------------
// @return [String]
@function map-merge-recursive($map1, $map2) {
    $ret: $map1;

    @each $key, $value in $map2 {
        @if map-get($ret, $key) != null and type-of($value) == map {
            $value: map-merge-recursive(map-get($ret, $key), $value);
        }

        $ret: map-merge($ret, ($key: $value));
    }

    @return $ret;
}
