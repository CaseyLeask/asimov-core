
$__a__map-cache: () !default;

// ==========================================================================
// Settings API
// ==========================================================================

// Returns $key's value from the core $settings map
// -----------------------------------------------------------------------------
// @param $key [String] : flattened key to lookup
// -----------------------------------------------------------------------------
// @return [Literal]
@function get($key) {
    @return lookup(get-component-map("settings", $settings, true), $key);
}

// Sets $key's to $value in the core $settings map if it currently has now value
// Returning the value of $key after it's been updated
// -----------------------------------------------------------------------------
// @param $key [String] : flattened key to lookup
// @param $value [Literal] : flattened key to lookup
// -----------------------------------------------------------------------------
// @return [Literal]
@function set-default($key, $value) {
    @if not get($key) {
        // Clear the settings caches!
        $__a__map-cache: map-merge($__a__map-cache, (
            "settings": null,
            "settings--flat": null,
        ));

        $value: set($key, $value);
    }

    // This rebuilds the settings cache if it was busted
    @return get($key);
}

// Sets $key's to $value in the core $settings map
// Returning the value of $key after it's been updated
// -----------------------------------------------------------------------------
// @param $key [String] : flattened key to lookup
// @param $value [Literal] : flattened key to lookup
// @param $_root [Map] : for internal use only
// -----------------------------------------------------------------------------
// @return [Literal]
@function set($key, $value) {
    // Clear the settings caches!
    $__a__map-cache: map-merge($__a__map-cache, (
        "settings": null,
        "settings--flat": null,
    ));

    $settings: _set($key, $value, $settings) !global;

    // This rebuilds the settings cache if it was busted
    @return get($key);
}

// Sets $key's to $value in the core $settings map
// Returning the value of $key after it's been updated
// -----------------------------------------------------------------------------
// @param $key [String] : flattened key to lookup
// @param $value [Literal] : flattened key to lookup
// @param $_root [Map] : for internal use only
// -----------------------------------------------------------------------------
// @return [Literal]
@function _set($key, $value, $root) {
    @if str-index($key, "/") > 0 {
        // Determin the $new key for the recursion
        $child-key: str-slice($key, str-index($key, "/") + 1);

        // Override the original $key and $value we can have one @return
        $key: str-slice($key, 1, str-index($key, "/") - 1);
        $value: _set($child-key, $value, map-get($root, $key))
    }

    @return map-merge($root, ($key: $value));
}


// ==========================================================================
// List functions
// ==========================================================================

// Return the first dimension of a multi dimensional $map with aliases resolved
// -----------------------------------------------------------------------------
// @param $map [Map] : map
// -----------------------------------------------------------------------------
// @return [Map]
@function get-map($map) {
    $ret: ();
    $base: null;
    @each $name, $value in $map {
        // ignore "base" as a value
        @if type-of($value) != map and $name != "base" {
            $ret: map-merge($ret, ($name: $value));
        } @else if $name == "base" {
            // preserver the "base" value for later
            $base: $value;
        }
    }

    // inject the "base" value for alias lookups only
    @return resolve-aliases($ret, ("base": $base));
}


// Turns multidimensional $map into a one-level map with aliases resolved.
// Map keys are composed by prefixing it's parent's key separated by a /
// -----------------------------------------------------------------------------
// @param $map [Map] : map
// @param $ret [Map] : the parent map to flatten $map into
// @param $prefix [String] : the prefix to append to $map's keys
// -----------------------------------------------------------------------------
// @return [Map]
@function flatten-map($map, $ret:(), $prefix:null) {
    @each $name, $value in $map {
        // TODO 3.3: this can be simplified with `if()`
        @if $prefix {
            $name: $prefix + if($name, "/#{$name}", "");
        }

        @if type-of($value) == map {
            // Append to the end of the root map because alias need to be after
            // the value they're aliasing to resolve correctly "#{$name}-base"
            $ls: append($value, null "#{$name}/base");
            $ret: flatten-map($ls, $ret, $name);
        } @else {
            $ret: map-merge($ret, ($name: $value));
        }
    }

    @return $ret;
}


// Takes a one dimensional $map and returns a new map with aliases resolved
// -----------------------------------------------------------------------------
// @param $map [Map] : map
// @param $extras [Map] : an external map to resolve aliases against
// -----------------------------------------------------------------------------
// @return [Map]
@function resolve-aliases($map, $extras:()) {
    $ret: ();
    @each $name, $value in $map {
        // Looks like an alias, try to resolve it, default to $value
        @if type-of($value) == string {
            $value: lookup($ret, $value, lookup($extras, $value, $value));
            $ret: map-merge($ret, ($name: $value));
        } @else {
            $ret: map-merge($ret, ($name: $value));
        }
    }

    @return $ret;
}


// Takes a one dimensional $map and returns a new map with aliases resolved
// -----------------------------------------------------------------------------
// @param $map [Map] : map
// @param $key [String] : key to lookup in map
// @param $default [Value] : the default value to return if key is not found
// @param $is-key [Bool] : if true $default is treated as a key in $map
// -----------------------------------------------------------------------------
// @return [Literal]
@function lookup($map, $key, $default:null, $is-key:false) {
    @if length($map) == 0 {
        @return $default;
    }

    @if map-has-key($map, $key) {
        @return map-get($map, $key);
    }

    @return if($is-key, lookup($map, $default), $default);
}


// Main proxy for accessing settings maps. Returned maps can either be just
// root level keys, or the entire map flattened with / used to flatten keys.
// Fetches are cached using $name and $flatten as seeds for the cache key.
// -----------------------------------------------------------------------------
// @param $name [String] : used a cache key
// @param $map [Map] : the map you want to retrieve
// @param $flatten [Bool] : whethen to flatten the map or just return root keys
// -----------------------------------------------------------------------------
// @return [Literal]
@function get-component-map($name, $map, $flatten:false) {
    @if $flatten {
        $name: "#{$name}--flat";
        $ret: lookup($__a__map-cache, $name);
        @if $ret == null {
            $ret: resolve-aliases(flatten-map($map));
            $__a__map-cache: map-merge($__a__map-cache, ($name: $ret));
        }
        @return $ret;
    } @else {
        $ret: lookup($__a__map-cache, $name);
        @if $ret == null {
            $ret: get-map($map);
            $__a__map-cache: map-merge($__a__map-cache, ($name: $ret));
        }
        @return $ret;
    }
}


// Joins all elements of single dimensional $list with $glue
// -------------------------------------------------------------------------------
// @param $list [List] : list
// @param $glue [String] : value to use as a join string
// -------------------------------------------------------------------------------
// @return [String]
@function implode($list, $glue:",") {
    @if length($list) == 1 {
        @return $list;
    }

    $ret: unquote("");
    @for $i from 1 through length($list) {
        $ret: if($ret == "", $ret, $ret + $glue) + nth($list, $i);
    }

    @return $ret;
}
